{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/indigo/source/css/style.less","path":"css/style.less","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/cc.png","path":"img/cc.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/main.min.js","path":"js/main.min.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/search.min.js","path":"js/search.min.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/wechat.jpg","path":"img/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/indigo/.editorconfig","hash":"67a03b88eadd7810f2e01866e73814074ecd3b87","modified":1596166757809},{"_id":"themes/indigo/README.md","hash":"cfc7d09fc2ce26003954d647e3bbf98f71574eb7","modified":1596166757809},{"_id":"themes/indigo/LICENSE","hash":"9dd0f70bc72c9d575447655526aded395bb93754","modified":1596166757809},{"_id":"themes/indigo/_config.yml","hash":"fbb6ddb657f968f4afc3f702435878e0ce469f90","modified":1596173606966},{"_id":"themes/indigo/package.json","hash":"3ad9b9ccb1ddaad3136f179a7ebff7d7b1c193f7","modified":1596166757820},{"_id":"themes/indigo/languages/en.yml","hash":"ba78def0453d08172248e220a1f9e145e99b4f23","modified":1596166757810},{"_id":"themes/indigo/languages/nl-NL","hash":"b540b76af76c1a180c517089ed2ad770cbded170","modified":1596166757810},{"_id":"themes/indigo/languages/ja.yml","hash":"65a32717335211a45771a21fb7d7778808c6f0aa","modified":1596166757810},{"_id":"themes/indigo/languages/zh-TW.yml","hash":"9b8bdd9c8b68716f364503926dca6ba8571ee5ff","modified":1596166757811},{"_id":"themes/indigo/languages/zh-CN.yml","hash":"6806e4c305facf19cbe4e37ccc5d6b00cb56e199","modified":1596166757810},{"_id":"themes/indigo/layout/categories.ejs","hash":"efae06b4d83aaf73ab93260381e891825bf404ac","modified":1596166757819},{"_id":"themes/indigo/layout/archive.ejs","hash":"6897178ba358379d6a4b7c0ba1bc2ab97ad5303a","modified":1596166757819},{"_id":"themes/indigo/layout/index.ejs","hash":"772c1985c7743e101598b4eddc253f9174c5605b","modified":1596166757819},{"_id":"themes/indigo/layout/category.ejs","hash":"e5ba5cc2e092c199285b8097ef12ffe70bf84c91","modified":1596166757819},{"_id":"themes/indigo/layout/layout.ejs","hash":"770af84fff104c398ce8b6c995130cddd3e9a1e9","modified":1596166757819},{"_id":"themes/indigo/layout/page.ejs","hash":"567c42b978da4c39b8b4982df19b940c26bc32a4","modified":1596166757820},{"_id":"themes/indigo/layout/post.ejs","hash":"efc3352828351f8574c51e8a93dc56c66660c3b1","modified":1596166757820},{"_id":"themes/indigo/layout/tag.ejs","hash":"90a231dea3a364b329a740e5d6c49c8cf5664fe9","modified":1596166757820},{"_id":"themes/indigo/layout/tags.ejs","hash":"1fc0461e9602b53899ec756e4361beb8cce74740","modified":1596166757820},{"_id":"themes/indigo/scripts/plugins.js","hash":"00ea278ea77733f546439aed507ce69a298da362","modified":1596166757820},{"_id":"source/_posts/hexo的使用.md","hash":"f393a05b0675965e39ec60443b50cbd696e0db4a","modified":1596119282187},{"_id":"source/_posts/HashMap.md","hash":"c0bd2697fc1fe8c68d61f45028a47b191edf6179","modified":1596119282183},{"_id":"source/_posts/java内存模型.md","hash":"41a5f81d40f5e4ef63619fe830fa2f984f75704b","modified":1596119282188},{"_id":"source/categories/index.md","hash":"ab9adb7483bf5ef900a328ed89bd42553e6cd30a","modified":1596166288181},{"_id":"source/tags/index.md","hash":"5742bfda2f05ed6a6fca513ec4d6ba134476bfc5","modified":1596166255711},{"_id":"themes/indigo/layout/_partial/after-footer.ejs","hash":"1351dbfca311f0d50a939f9e1a91c4f65bbcdf5f","modified":1596166757811},{"_id":"themes/indigo/layout/_partial/archive.ejs","hash":"c294c98617ce14082f9b3d5eec83328f480f5597","modified":1596166757811},{"_id":"themes/indigo/layout/_partial/footer.ejs","hash":"c78444f5b350ca79b260361bf3e5b6361d2661ba","modified":1596166757812},{"_id":"themes/indigo/layout/_partial/head.ejs","hash":"9dfc591ec6c918c5b60b6ccbc5d1e18fea9faf8e","modified":1596166757812},{"_id":"themes/indigo/layout/_partial/header.ejs","hash":"648db446567a81371b8a29d719d13636aa157012","modified":1596166757812},{"_id":"themes/indigo/layout/_partial/index-item.ejs","hash":"7208d4083ee3355aa969972a2ce249a67d56b3a6","modified":1596166757812},{"_id":"themes/indigo/layout/_partial/loading.ejs","hash":"8b3e037dd5f3d4564012689c5cd6f63caf73df0f","modified":1596166757813},{"_id":"themes/indigo/layout/_partial/menu.ejs","hash":"ea6aded24a68de0914f24b3760f766b5e1c9835a","modified":1596166757813},{"_id":"themes/indigo/layout/_partial/paginator.ejs","hash":"13952250463f70d1c1bbbfdd7f4ee8160dd6d99b","modified":1596166757813},{"_id":"themes/indigo/layout/_partial/post.ejs","hash":"20597ac0d547aea37680ecf195eb129fe5ee19d8","modified":1596166757815},{"_id":"themes/indigo/layout/_partial/script.ejs","hash":"b28106b35a9fc63eefa69c2ca8b923eb1f731832","modified":1596166757818},{"_id":"themes/indigo/layout/_partial/search.ejs","hash":"752109904304fdb8e988ee1254df2af9c0701466","modified":1596166757818},{"_id":"themes/indigo/layout/_partial/tags-bar.ejs","hash":"30ec74f081cc4c273a7bcd5d57da99072e9f0755","modified":1596166757818},{"_id":"themes/indigo/source/css/style.less","hash":"cf362925ae099b810fd5763e6b724b823612ed15","modified":1596166757850},{"_id":"themes/indigo/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1596166757851},{"_id":"themes/indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1596166757851},{"_id":"themes/indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1596166757851},{"_id":"themes/indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1596166757852},{"_id":"themes/indigo/source/js/main.min.js","hash":"e77a89fe5a9827ac590a288778176b233dd900ad","modified":1596166757853},{"_id":"themes/indigo/source/js/main.js","hash":"ff44bb7b2f1f08757093fd6ffa92c9ac2b674109","modified":1596166757853},{"_id":"themes/indigo/source/js/search.js","hash":"a4d6c9c566ec1ca71ddacfd14c58f7ddaf9db24d","modified":1596166757853},{"_id":"themes/indigo/source/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1596166757853},{"_id":"source/_posts/HashMap/1563864906121.png","hash":"21cd516efab059711e7cdf39f8603aba4fb7d903","modified":1596119282186},{"_id":"source/_posts/HashMap/1563867424345345.png","hash":"270bdde9379f34d4a12bedfc7ffa53b1328b006f","modified":1596119282187},{"_id":"source/_posts/java内存模型/2019071004.png","hash":"7245dba03c95471a4c7684b43308db73127301d7","modified":1596119282197},{"_id":"themes/indigo/source/img/avatar.jpg","hash":"cd785e52f8ee5e8ef24d454aaa114ef305442cdb","modified":1596167920063},{"_id":"themes/indigo/source/img/alipay.jpg","hash":"082758ba264789b1c5c3a2fa0cfdc4c90f531381","modified":1596168135395},{"_id":"themes/indigo/source/img/wechat.jpg","hash":"d38b1f3240bd30eb3fd960362e7bad7a685819dd","modified":1596168112090},{"_id":"source/_posts/HashMap/1563766617123.png","hash":"76078103b1ef0eb6d5fae17d0aa1111c44f6896f","modified":1596119282185},{"_id":"source/_posts/java内存模型/2019071003.png","hash":"aa71a8edd74320cedbc868860f95b4046ba68656","modified":1596119282196},{"_id":"themes/indigo/layout/_partial/plugins/disqus.ejs","hash":"86fe837ab16cb60754b0a73bb9efa38b04f3023f","modified":1596166757813},{"_id":"themes/indigo/layout/_partial/plugins/baidu.ejs","hash":"da1355eea131952031e54c45560555e6d3aa5a33","modified":1596166757813},{"_id":"themes/indigo/layout/_partial/plugins/dynamic-title.ejs","hash":"3b877868c4a6fc217ea6f3314544830280a77472","modified":1596166757814},{"_id":"themes/indigo/layout/_partial/plugins/gitalk.ejs","hash":"8a0c390ed475600c627bcfa41df15a54f60eca3c","modified":1596166757814},{"_id":"themes/indigo/layout/_partial/plugins/gitment.ejs","hash":"5f6ceb7f4b9b579e8e3f87894447f556a53f9385","modified":1596166757814},{"_id":"themes/indigo/layout/_partial/plugins/google-analytics.ejs","hash":"b5b87761751a897949e085a8f1ace78b0b8babd5","modified":1596166757814},{"_id":"themes/indigo/layout/_partial/plugins/hyper-comments.ejs","hash":"d0e6f1d713e7a1c0cc5fe25f3e574a4b791f938a","modified":1596166757814},{"_id":"themes/indigo/layout/_partial/plugins/mathjax.ejs","hash":"3a5c9f7d22d30cd8ffa4e83a8d3976db22815994","modified":1596166757815},{"_id":"themes/indigo/layout/_partial/plugins/page-visit.ejs","hash":"bb9deb32c54ea6820f622b923e62592915e9f21f","modified":1596166757815},{"_id":"themes/indigo/layout/_partial/plugins/site-visit.ejs","hash":"a2c247c2e32016563dd6a22c21474072d93f4dbd","modified":1596166757815},{"_id":"themes/indigo/layout/_partial/plugins/tajs.ejs","hash":"ef9c77d8c6e004b014c83c5f9333e7174f8bafa3","modified":1596166757815},{"_id":"themes/indigo/layout/_partial/plugins/valine.ejs","hash":"0a6245da90d54177441d32a6f1766b4f434660db","modified":1596166757815},{"_id":"themes/indigo/layout/_partial/post/category.ejs","hash":"c08e44cbd7315dec7afb6054b04d3c7b82c3bde8","modified":1596166757816},{"_id":"themes/indigo/layout/_partial/post/comment.ejs","hash":"2751d0f694f72bb886664ace021d698ea0e8f0c7","modified":1596166757816},{"_id":"themes/indigo/layout/_partial/post/copyright.ejs","hash":"dd1dcc7776021ab3d68065f8532efead4c2b8051","modified":1596166757816},{"_id":"themes/indigo/layout/_partial/post/date.ejs","hash":"c5adcec8db1506c378d39855a697e1bb1165646c","modified":1596166757816},{"_id":"themes/indigo/layout/_partial/post/nav.ejs","hash":"03719097851575a2c1bb95774058b224f6402a1f","modified":1596166757817},{"_id":"themes/indigo/layout/_partial/post/head-meta.ejs","hash":"f137c126672769e9571be2bb0a70ea8dda644b0e","modified":1596166757816},{"_id":"themes/indigo/layout/_partial/post/reward-btn.ejs","hash":"b46160005224821a439dec9f1ff183e2f66d9f4b","modified":1596166757817},{"_id":"themes/indigo/layout/_partial/post/reward.ejs","hash":"097c0276a61665e5ee96e5d5d85a7d6ae5ab2f49","modified":1596166757817},{"_id":"themes/indigo/layout/_partial/post/share-fab.ejs","hash":"2ec7de870988cfbc8ea9872cddf7e4076ac64a57","modified":1596166757817},{"_id":"themes/indigo/layout/_partial/post/share.ejs","hash":"7d79a67b3e5e6989f22fb0e0904fa540bfca5fcc","modified":1596166757817},{"_id":"themes/indigo/layout/_partial/post/tag.ejs","hash":"412894001b1ac6e63012b26b1109a0856651c076","modified":1596166757818},{"_id":"themes/indigo/layout/_partial/post/title.ejs","hash":"eaad7af7888bddd7095243a43ff38f55ad8c494a","modified":1596166757818},{"_id":"themes/indigo/layout/_partial/post/toc.ejs","hash":"d534b888d24df7703c632539d4bdd638fa764e98","modified":1596166757818},{"_id":"themes/indigo/layout/_partial/post/updated.ejs","hash":"00fedf7971c0bda0623d968bc0614e512d19a985","modified":1596166757818},{"_id":"themes/indigo/source/css/_partial/archives.less","hash":"382fc22cd5cc073e881768a65600d97eba9f1d21","modified":1596166757821},{"_id":"themes/indigo/source/css/_partial/article.less","hash":"f047c8ca92f9e6a8e1299ace0cce91514631a21c","modified":1596166757821},{"_id":"themes/indigo/source/css/_partial/header.less","hash":"880b4a28e97d556ed15b07642d25115f9b6ba4f6","modified":1596166757822},{"_id":"themes/indigo/source/css/_partial/gotop.less","hash":"bad63006b3bd4849bf53ad38482af0d9971061d3","modified":1596166757822},{"_id":"themes/indigo/source/css/_partial/highlight.less","hash":"99e48793dc0b4ffb66ecaf2d1315145872f9bb98","modified":1596166757822},{"_id":"themes/indigo/source/css/_partial/lightbox.less","hash":"38419aaf3c1832e84ade331f051f110fdc8b960f","modified":1596166757823},{"_id":"themes/indigo/source/css/_partial/layout.less","hash":"5f783f34bf093e654e8922ed4a2af8b7b2cd41c4","modified":1596166757823},{"_id":"themes/indigo/source/css/_partial/loading.less","hash":"85157ddf3877b5c58e8f1d737dda3dfb1bfd540b","modified":1596166757823},{"_id":"themes/indigo/source/css/_partial/page.less","hash":"33b0a5edcedc26a4c592c812c5785bb20d3c93db","modified":1596166757823},{"_id":"themes/indigo/source/css/_partial/postlist.less","hash":"516cded3c7f1db4cacfa898bcaf0adfae7f3a2e1","modified":1596166757823},{"_id":"themes/indigo/source/css/_partial/reward.less","hash":"f5e89ea5414e3096a28c8c96e86c3f669040a892","modified":1596166757824},{"_id":"themes/indigo/source/css/_partial/roboto.less","hash":"3e457942995da8840e7662fa6cb551a7e12ea294","modified":1596166757824},{"_id":"themes/indigo/source/css/_partial/search.less","hash":"dbc23e77e586ee682a21475f5eb568628ea6720f","modified":1596166757824},{"_id":"themes/indigo/source/css/_partial/share.less","hash":"a683c96a59470efd35722b763c55149a46e35156","modified":1596166757824},{"_id":"themes/indigo/source/css/_partial/tags.less","hash":"01eb7f84193180928a6ed4796ee8802f6c1628e7","modified":1596166757824},{"_id":"themes/indigo/source/css/_partial/waves.less","hash":"a02eaa601887f947257f6016679b62dc96a61c0c","modified":1596166757825},{"_id":"themes/indigo/source/css/_plugin/valine.less","hash":"b8f8d8037fb3c8525da12e580bd9e2ff9f298132","modified":1596166757825},{"_id":"themes/indigo/source/css/_partial/variable.less","hash":"7893dcbd6cd578c67dbe81053449b0d3612b2084","modified":1596176755917},{"_id":"themes/indigo/layout/_partial/plugins/uyan.ejs","hash":"ddf290e90dc1c779f42a48e1bd852ca932148dfb","modified":1596166757815},{"_id":"themes/indigo/source/css/_partial/fontawesome.less","hash":"a3ecbd6ccf5b56ac39df710c34a149b82989a498","modified":1596166757822},{"_id":"source/_posts/java内存模型/2019071002.png","hash":"e2d175b846d389e4227fad7300cfe1c9e64b93b6","modified":1596119282194},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1596166757836},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1596166757839},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1596166757839},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1596166757841},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1596166757842},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1596166757844},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1596166757844},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1596166757846},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1596166757847},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1596166757847},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1596166757849},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1596166757850},{"_id":"source/_posts/java内存模型/2019071005.png","hash":"46c5c18408b4065f786eec0532b2fc76ffebeb14","modified":1596119282200},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1596166757836},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1596166757835},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1596166757838},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1596166757841},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1596166757841},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1596166757844},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1596166757846},{"_id":"source/_posts/java内存模型/2019071001.png","hash":"589a70ba2de46403fde46a0287952e0c23920e28","modified":1596119282191},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1596166757827},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1596166757829},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1596166757834},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1596166757837},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1596166757843},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1596166757848},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1596166757832},{"_id":"public/atom.xml","hash":"3f497a48d5c88a7ab63cb5720a10c746acf83785","modified":1596176768025},{"_id":"public/content.json","hash":"b96c0500acd8954fc8a7b18082002edc058e210e","modified":1596176768025},{"_id":"public/categories/index.html","hash":"2e8eddc15d45f6ef192d9d7528a82a314dd0946b","modified":1596176768025},{"_id":"public/tags/index.html","hash":"4209416ecf59e9f7dcbcd5193887b0a8e0463729","modified":1596176768025},{"_id":"public/archives/index.html","hash":"704b036e094ed883b0077b80c08108792bfc3208","modified":1596176768025},{"_id":"public/archives/2018/index.html","hash":"089336b647043ad6babde8afa8f80d12c90f9943","modified":1596176768025},{"_id":"public/archives/2018/11/index.html","hash":"c914c889919f77f1b8acd5b24332bab2ac937cf5","modified":1596176768025},{"_id":"public/index.html","hash":"c57bd525686a72ab74a5cc2bbeb4ea309036fdf9","modified":1596176768025},{"_id":"public/archives/2019/index.html","hash":"56c433dfa9c3bdc5e82fb1f075ed3d1e1175a39b","modified":1596176768025},{"_id":"public/archives/2019/07/index.html","hash":"9da19ae2e4fc1ddf7595c3af836d76a3a0d3c327","modified":1596176768025},{"_id":"public/categories/集合/index.html","hash":"20f9cf966856443cbd2a2eb7d35e68768df7ba55","modified":1596176768025},{"_id":"public/categories/Hexo教程/index.html","hash":"387c26610a1fa14c40edcda85495a16bd1b8f911","modified":1596176768025},{"_id":"public/categories/java技术/index.html","hash":"b8ab8f912ad7a52a4d9485e6d17502f513f68706","modified":1596176768025},{"_id":"public/tags/源码阅读/index.html","hash":"eb26a5ef5b095f2dc401a0be97b651c945b3ef2e","modified":1596176768025},{"_id":"public/tags/Hexo/index.html","hash":"cad8c6f832a6e453ff086f5b235573e2d261c124","modified":1596176768025},{"_id":"public/tags/Blog/index.html","hash":"e689f3315706d25fde7409efcbfa031aa84fdba5","modified":1596176768025},{"_id":"public/tags/java内存/index.html","hash":"a0eaff7189ecfb19d5fbb06204c18d3bff5125af","modified":1596176768025},{"_id":"public/2019/07/11/HashMap/index.html","hash":"434618c3b81610ff20c806207a2e822fa87e5a7d","modified":1596176768025},{"_id":"public/2019/07/10/java内存模型/index.html","hash":"b8040dd0722aec6275d99c7d41906662370cee76","modified":1596176768025},{"_id":"public/2018/11/07/hexo的使用/index.html","hash":"889c6c0adb6192715413ef182859576bf3a7aa39","modified":1596176768025},{"_id":"public/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1596176768025},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1596176768025},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1596176768025},{"_id":"public/2019/07/11/HashMap/1563864906121.png","hash":"21cd516efab059711e7cdf39f8603aba4fb7d903","modified":1596176768025},{"_id":"public/2019/07/11/HashMap/1563867424345345.png","hash":"270bdde9379f34d4a12bedfc7ffa53b1328b006f","modified":1596176768025},{"_id":"public/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1596176768025},{"_id":"public/img/avatar.jpg","hash":"cd785e52f8ee5e8ef24d454aaa114ef305442cdb","modified":1596176768025},{"_id":"public/img/alipay.jpg","hash":"082758ba264789b1c5c3a2fa0cfdc4c90f531381","modified":1596176768025},{"_id":"public/img/wechat.jpg","hash":"d38b1f3240bd30eb3fd960362e7bad7a685819dd","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1596176768025},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1596176768025},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1596176768025},{"_id":"public/2019/07/11/HashMap/1563766617123.png","hash":"76078103b1ef0eb6d5fae17d0aa1111c44f6896f","modified":1596176768025},{"_id":"public/2019/07/10/java内存模型/2019071004.png","hash":"7245dba03c95471a4c7684b43308db73127301d7","modified":1596176768025},{"_id":"public/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1596176768025},{"_id":"public/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1596176768025},{"_id":"public/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1596176768025},{"_id":"public/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1596176768025},{"_id":"public/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1596176768025},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1596176768025},{"_id":"public/2019/07/10/java内存模型/2019071002.png","hash":"e2d175b846d389e4227fad7300cfe1c9e64b93b6","modified":1596176768025},{"_id":"public/2019/07/10/java内存模型/2019071003.png","hash":"aa71a8edd74320cedbc868860f95b4046ba68656","modified":1596176768025},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1596176768025},{"_id":"public/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1596176768025},{"_id":"public/2019/07/10/java内存模型/2019071005.png","hash":"46c5c18408b4065f786eec0532b2fc76ffebeb14","modified":1596176768025},{"_id":"public/css/style.css","hash":"678a8094ac97bb88f818fe50c5f434d2f9f989f9","modified":1596176768025},{"_id":"public/2019/07/10/java内存模型/2019071001.png","hash":"589a70ba2de46403fde46a0287952e0c23920e28","modified":1596176768025},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1596176768025}],"Category":[{"name":"集合","_id":"ckd9ufp4c0003pwlg72qlfr8o"},{"name":"Hexo教程","_id":"ckd9ufp4g0006pwlgh9nv73l1"},{"name":"java技术","_id":"ckd9ufp4h000apwlggtyk3uff"}],"Data":[],"Page":[{"layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\nlayout: categories\ncomments: false\n---","date":"2020-07-31T03:31:28.181Z","updated":"2020-07-31T03:31:28.181Z","path":"categories/index.html","title":"","_id":"ckd9ufp4a0001pwlg00f1g6s7","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\nlayout: tags\ncomments: false\n---\n","date":"2020-07-31T03:30:55.711Z","updated":"2020-07-31T03:30:55.711Z","path":"tags/index.html","title":"","_id":"ckd9ufp4v000ipwlg3u8j8flm","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"HashMap源码解析","date":"2019-07-11T03:14:24.000Z","_content":"## HashMap源码解析\n1. 默认的常量\n```java\n//创建 HashMap 时未指定初始容量情况下的默认容量  16\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4;\n//HashMap 的最大容量 2^30 \nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n//HashMap 默认的装载因子,当 HashMap 中元素数量超过容量装载因子时，进行　resize()　操作\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f; \n//链表转红黑树的阈值 \nstatic final int TREEIFY_THRESHOLD = 8; \n//用来确定何时将解决 hash 冲突的红黑树转变为链表\nstatic final int UNTREEIFY_THRESHOLD = 6;\n```\n2. 存储结构\n内部包含了一个 Node 类型的数组 table。观察 Node 可以发现table是一个链表\n```java\n    /**\n     * The table, initialized on first use, and resized as\n     * necessary. When allocated, length is always a power of two.\n     * (We also tolerate length zero in some operations to allow\n     * bootstrapping mechanics that are currently not needed.)\n     */\n    transient Node<K,V>[] table;\n```\nNode 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 table 是一个链表。即数组中的每个位置被当\n成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结\n果相同的 Ndoe.\n```java\n    static class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;//保存节点的hash值\n        final K key;//保存节点的key值\n        V value;//保存节点的value值\n        Node<K,V> next;//指向链表结构下的当前节点的 next 节点，红黑树 TreeNode 节点中也有用到\n\n        Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + \"=\" + value; }\n\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n    }\n```\n TreeNode<K,V> 继承 LinkedHashMap.Entry<K,V>，用来实现红黑树相关的存储结构\n```java\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n        TreeNode<K,V> parent;  // 存储当前节点的父节点\n        TreeNode<K,V> left;　//存储当前节点的左孩子\n        TreeNode<K,V> right;　//存储当前节点的右孩子\n        TreeNode<K,V> prev;    // 存储当前节点的前一个节点\n        boolean red;　// 存储当前节点的颜色（红、黑）\n        TreeNode(int hash, K key, V val, Node<K,V> next) {\n            super(hash, key, val, next);\n        }\n        TreeNode(int hash, K key, V val, Node<K,V> next) {\n            super(hash, key, val, next);\n        }\n\n        /**\n         * Returns root of tree containing this node.\n         */\n        final TreeNode<K,V> root() {\n            for (TreeNode<K,V> r = this, p;;) {\n                if ((p = r.parent) == null)\n                    return r;\n                r = p;\n            }\n        }\n```\n\n3. HashMap的结构<br>\n![avatar](1563864906121.png)<br>\n\n\n4. 拉链法的工作原理\n```java\nHashMap<String, String> map = new HashMap<>();\nmap.put(\"K1\", \"V1\");\nmap.put(\"K2\", \"V2\");\nmap.put(\"K3\", \"V3\");\n```\n. 新建一个 HashMap，默认大小为 16；<br>\n. 插入 <K1,V1> 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。<br>\n. 插入 <K2,V2> 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。<br>\n. 插入 <K3,V3> 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在<K2,V2> 前面。<br>\n注意：应该注意到链表的插入是以头插法方式进行的，例如上面的 <K3,V3> 不是插在 <K2,V2> 后面，而是插入在链表头\n部<br>\n\n查找需要分成两步进行：\n计算键值对所在的桶；\n在链表上顺序查找，时间复杂度显然和链表的长度成正比。\n\n5. put操作\n```java\npublic V put(K key, V value) {\n    if (table == EMPTY_TABLE) {\n        inflateTable(threshold);\n    } \n    // 键为 null 单独处理\n    if (key == null)\n        return putForNullKey(value);\n    int hash = hash(key);\n    // 确定桶下标\n    int i = indexFor(hash, table.length);\n    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n    modCount++;\n    // 插入新键值对\n    addEntry(hash, key, value, i);\n    return null;\n    }\n\n```\n确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，\n那么就可以将这个操作转换为位运算。\n```java\nstatic int indexFor(int h, int length) {\n    return h & (length-1);\n}\n```\n\n\n\nHashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下\n标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。\n```java\n    private V putForNullKey(V value) {\n        for (Entry<K,V> e = table[0]; e != null; e = e.next) {\n            if (e.key == null) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n            modCount++;\n            addEntry(0, null, value, 0);\n        return null;\n    }\n```\n使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。\n```java\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        resize(2 * table.length);\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = indexFor(hash, table.length);\n    } \n        createEntry(hash, key, value, bucketIndex);\n    } \nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n    Entry<K,V> e = table[bucketIndex];\n    // 头插法，链表头部指向新的键值对\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    size++;\n}\n```\n\n6. 扩容-基本原理\n设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长\n度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。\n为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。\nHashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。\n和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。\n\n![avatar](1563867424345345.png)<br>\n从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。\n```java\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    Entry<K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    //键值对的数量size大于threshold时进行扩容操作\n    if (size++ >= threshold)\n    //扩容使用resize()实现\n        resize(2 * table.length);\n}\n```\n扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此\n这一步是很费时的。\n```java\nvoid resize(int newCapacity) {\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) {\n        threshold = Integer.MAX_VALUE;\n        return;\n    }\n    Entry[] newTable = new Entry[newCapacity];\n    transfer(newTable);\n    table = newTable;\n    threshold = (int)(newCapacity * loadFactor);\n}\n\nvoid transfer(Entry[] newTable) {\n    Entry[] src = table;\n    int newCapacity = newTable.length;\n    for (int j = 0; j < src.length; j++) {\n        Entry<K,V> e = src[j];\n        if (e != null) {\n            src[j] = null;\n            do {\n                Entry<K,V> next = e.next;\n                int i = indexFor(e.hash, newCapacity);\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            } while (e != null);\n        }\n    }\n}\n\n```\n7. 扩容-重新计算桶下标\n在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。\n假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：<br>\ncapacity     : 00010000<br>\nnew capacity : 00100000\n对于一个 Key，\n\n它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；\n如果为 1，那么得到的结果为原来的结果 +16。\n\n8. 计算数组容量\nHashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。<br>\n\n先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：\n```txt\nmask |= mask >> 1 11011000\nmask |= mask >> 2 11111110\nmask |= mask >> 4 11111111\n```\n\n8. 链表转红黑树\n从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。","source":"_posts/HashMap.md","raw":"---\ntitle: HashMap源码解析\ndate: 2019-07-11 11:14:24\ntags: \n- 源码阅读\ncategories: \"集合\"    \n---\n## HashMap源码解析\n1. 默认的常量\n```java\n//创建 HashMap 时未指定初始容量情况下的默认容量  16\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4;\n//HashMap 的最大容量 2^30 \nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n//HashMap 默认的装载因子,当 HashMap 中元素数量超过容量装载因子时，进行　resize()　操作\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f; \n//链表转红黑树的阈值 \nstatic final int TREEIFY_THRESHOLD = 8; \n//用来确定何时将解决 hash 冲突的红黑树转变为链表\nstatic final int UNTREEIFY_THRESHOLD = 6;\n```\n2. 存储结构\n内部包含了一个 Node 类型的数组 table。观察 Node 可以发现table是一个链表\n```java\n    /**\n     * The table, initialized on first use, and resized as\n     * necessary. When allocated, length is always a power of two.\n     * (We also tolerate length zero in some operations to allow\n     * bootstrapping mechanics that are currently not needed.)\n     */\n    transient Node<K,V>[] table;\n```\nNode 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 table 是一个链表。即数组中的每个位置被当\n成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结\n果相同的 Ndoe.\n```java\n    static class Node<K,V> implements Map.Entry<K,V> {\n        final int hash;//保存节点的hash值\n        final K key;//保存节点的key值\n        V value;//保存节点的value值\n        Node<K,V> next;//指向链表结构下的当前节点的 next 节点，红黑树 TreeNode 节点中也有用到\n\n        Node(int hash, K key, V value, Node<K,V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n\n        public final K getKey()        { return key; }\n        public final V getValue()      { return value; }\n        public final String toString() { return key + \"=\" + value; }\n\n        public final int hashCode() {\n            return Objects.hashCode(key) ^ Objects.hashCode(value);\n        }\n\n        public final V setValue(V newValue) {\n            V oldValue = value;\n            value = newValue;\n            return oldValue;\n        }\n\n        public final boolean equals(Object o) {\n            if (o == this)\n                return true;\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n                if (Objects.equals(key, e.getKey()) &&\n                    Objects.equals(value, e.getValue()))\n                    return true;\n            }\n            return false;\n        }\n    }\n```\n TreeNode<K,V> 继承 LinkedHashMap.Entry<K,V>，用来实现红黑树相关的存储结构\n```java\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n        TreeNode<K,V> parent;  // 存储当前节点的父节点\n        TreeNode<K,V> left;　//存储当前节点的左孩子\n        TreeNode<K,V> right;　//存储当前节点的右孩子\n        TreeNode<K,V> prev;    // 存储当前节点的前一个节点\n        boolean red;　// 存储当前节点的颜色（红、黑）\n        TreeNode(int hash, K key, V val, Node<K,V> next) {\n            super(hash, key, val, next);\n        }\n        TreeNode(int hash, K key, V val, Node<K,V> next) {\n            super(hash, key, val, next);\n        }\n\n        /**\n         * Returns root of tree containing this node.\n         */\n        final TreeNode<K,V> root() {\n            for (TreeNode<K,V> r = this, p;;) {\n                if ((p = r.parent) == null)\n                    return r;\n                r = p;\n            }\n        }\n```\n\n3. HashMap的结构<br>\n![avatar](1563864906121.png)<br>\n\n\n4. 拉链法的工作原理\n```java\nHashMap<String, String> map = new HashMap<>();\nmap.put(\"K1\", \"V1\");\nmap.put(\"K2\", \"V2\");\nmap.put(\"K3\", \"V3\");\n```\n. 新建一个 HashMap，默认大小为 16；<br>\n. 插入 <K1,V1> 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。<br>\n. 插入 <K2,V2> 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。<br>\n. 插入 <K3,V3> 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在<K2,V2> 前面。<br>\n注意：应该注意到链表的插入是以头插法方式进行的，例如上面的 <K3,V3> 不是插在 <K2,V2> 后面，而是插入在链表头\n部<br>\n\n查找需要分成两步进行：\n计算键值对所在的桶；\n在链表上顺序查找，时间复杂度显然和链表的长度成正比。\n\n5. put操作\n```java\npublic V put(K key, V value) {\n    if (table == EMPTY_TABLE) {\n        inflateTable(threshold);\n    } \n    // 键为 null 单独处理\n    if (key == null)\n        return putForNullKey(value);\n    int hash = hash(key);\n    // 确定桶下标\n    int i = indexFor(hash, table.length);\n    // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n    modCount++;\n    // 插入新键值对\n    addEntry(hash, key, value, i);\n    return null;\n    }\n\n```\n确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，\n那么就可以将这个操作转换为位运算。\n```java\nstatic int indexFor(int h, int length) {\n    return h & (length-1);\n}\n```\n\n\n\nHashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下\n标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。\n```java\n    private V putForNullKey(V value) {\n        for (Entry<K,V> e = table[0]; e != null; e = e.next) {\n            if (e.key == null) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n            modCount++;\n            addEntry(0, null, value, 0);\n        return null;\n    }\n```\n使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。\n```java\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    if ((size >= threshold) && (null != table[bucketIndex])) {\n        resize(2 * table.length);\n        hash = (null != key) ? hash(key) : 0;\n        bucketIndex = indexFor(hash, table.length);\n    } \n        createEntry(hash, key, value, bucketIndex);\n    } \nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n    Entry<K,V> e = table[bucketIndex];\n    // 头插法，链表头部指向新的键值对\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    size++;\n}\n```\n\n6. 扩容-基本原理\n设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长\n度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。\n为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。\nHashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。\n和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。\n\n![avatar](1563867424345345.png)<br>\n从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。\n```java\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n    Entry<K,V> e = table[bucketIndex];\n    table[bucketIndex] = new Entry<>(hash, key, value, e);\n    //键值对的数量size大于threshold时进行扩容操作\n    if (size++ >= threshold)\n    //扩容使用resize()实现\n        resize(2 * table.length);\n}\n```\n扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此\n这一步是很费时的。\n```java\nvoid resize(int newCapacity) {\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    if (oldCapacity == MAXIMUM_CAPACITY) {\n        threshold = Integer.MAX_VALUE;\n        return;\n    }\n    Entry[] newTable = new Entry[newCapacity];\n    transfer(newTable);\n    table = newTable;\n    threshold = (int)(newCapacity * loadFactor);\n}\n\nvoid transfer(Entry[] newTable) {\n    Entry[] src = table;\n    int newCapacity = newTable.length;\n    for (int j = 0; j < src.length; j++) {\n        Entry<K,V> e = src[j];\n        if (e != null) {\n            src[j] = null;\n            do {\n                Entry<K,V> next = e.next;\n                int i = indexFor(e.hash, newCapacity);\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            } while (e != null);\n        }\n    }\n}\n\n```\n7. 扩容-重新计算桶下标\n在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。\n假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：<br>\ncapacity     : 00010000<br>\nnew capacity : 00100000\n对于一个 Key，\n\n它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；\n如果为 1，那么得到的结果为原来的结果 +16。\n\n8. 计算数组容量\nHashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。<br>\n\n先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：\n```txt\nmask |= mask >> 1 11011000\nmask |= mask >> 2 11111110\nmask |= mask >> 4 11111111\n```\n\n8. 链表转红黑树\n从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。","slug":"HashMap","published":1,"updated":"2020-07-30T14:28:02.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd9ufp460000pwlg54gg5ann","content":"<h2 id=\"HashMap源码解析\"><a href=\"#HashMap源码解析\" class=\"headerlink\" title=\"HashMap源码解析\"></a>HashMap源码解析</h2><ol>\n<li><p>默认的常量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建 HashMap 时未指定初始容量情况下的默认容量  16</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"comment\">//HashMap 的最大容量 2^30 </span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"comment\">//HashMap 默认的装载因子,当 HashMap 中元素数量超过容量装载因子时，进行　resize()　操作</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>; </span><br><span class=\"line\"><span class=\"comment\">//链表转红黑树的阈值 </span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>; </span><br><span class=\"line\"><span class=\"comment\">//用来确定何时将解决 hash 冲突的红黑树转变为链表</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure></li>\n<li><p>存储结构<br>内部包含了一个 Node 类型的数组 table。观察 Node 可以发现table是一个链表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The table, initialized on first use, and resized as</span></span><br><span class=\"line\"><span class=\"comment\"> * necessary. When allocated, length is always a power of two.</span></span><br><span class=\"line\"><span class=\"comment\"> * (We also tolerate length zero in some operations to allow</span></span><br><span class=\"line\"><span class=\"comment\"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>\n<p>Node 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 table 是一个链表。即数组中的每个位置被当<br>成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结<br>果相同的 Ndoe.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;<span class=\"comment\">//保存节点的hash值</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;<span class=\"comment\">//保存节点的key值</span></span><br><span class=\"line\">    V value;<span class=\"comment\">//保存节点的value值</span></span><br><span class=\"line\">    Node&lt;K,V&gt; next;<span class=\"comment\">//指向链表结构下的当前节点的 next 节点，红黑树 TreeNode 节点中也有用到</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span>        </span>&#123; <span class=\"keyword\">return</span> key; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span>      </span>&#123; <span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> key + <span class=\"string\">\"=\"</span> + value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">        V oldValue = value;</span><br><span class=\"line\">        value = newValue;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</span><br><span class=\"line\">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">                Objects.equals(value, e.getValue()))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>TreeNode&lt;K,V&gt; 继承 LinkedHashMap.Entry&lt;K,V&gt;，用来实现红黑树相关的存储结构</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// 存储当前节点的父节点</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; left;　<span class=\"comment\">//存储当前节点的左孩子</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; right;　<span class=\"comment\">//存储当前节点的右孩子</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// 存储当前节点的前一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> red;　<span class=\"comment\">// 存储当前节点的颜色（红、黑）</span></span><br><span class=\"line\">        TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * Returns root of tree containing this node.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">root</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; r = <span class=\"keyword\">this</span>, p;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((p = r.parent) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                r = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HashMap的结构<br></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"1563864906121.png\" alt=\"avatar\" title=\"\">\n                </div>\n                <div class=\"image-caption\">avatar</div>\n            </figure><br>\n\n\n</li>\n</ol>\n<ol start=\"4\">\n<li>拉链法的工作原理<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">\"K1\"</span>, <span class=\"string\">\"V1\"</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">\"K2\"</span>, <span class=\"string\">\"V2\"</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">\"K3\"</span>, <span class=\"string\">\"V3\"</span>);</span><br></pre></td></tr></table></figure>\n. 新建一个 HashMap，默认大小为 16；<br><br>. 插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。<br><br>. 插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。<br><br>. 插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在&lt;K2,V2&gt; 前面。<br><br>注意：应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头<br>部<br></li>\n</ol>\n<p>查找需要分成两步进行：<br>计算键值对所在的桶；<br>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</p>\n<ol start=\"5\">\n<li>put操作<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class=\"line\">        inflateTable(threshold);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 键为 null 单独处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> putForNullKey(value);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key);</span><br><span class=\"line\">    <span class=\"comment\">// 确定桶下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);</span><br><span class=\"line\">    <span class=\"comment\">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"comment\">// 插入新键值对</span></span><br><span class=\"line\">    addEntry(hash, key, value, i);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，<br>那么就可以将这个操作转换为位运算。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下<br>标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">putForNullKey</span><span class=\"params\">(V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[<span class=\"number\">0</span>]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.key == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        addEntry(<span class=\"number\">0</span>, <span class=\"keyword\">null</span>, value, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size &gt;= threshold) &amp;&amp; (<span class=\"keyword\">null</span> != table[bucketIndex])) &#123;</span><br><span class=\"line\">        resize(<span class=\"number\">2</span> * table.length);</span><br><span class=\"line\">        hash = (<span class=\"keyword\">null</span> != key) ? hash(key) : <span class=\"number\">0</span>;</span><br><span class=\"line\">        bucketIndex = indexFor(hash, table.length);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">        createEntry(hash, key, value, bucketIndex);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class=\"line\">    <span class=\"comment\">// 头插法，链表头部指向新的键值对</span></span><br><span class=\"line\">    table[bucketIndex] = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>扩容-基本原理<br>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长<br>度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。<br>为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。<br>HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。<br>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</li>\n</ol>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"1563867424345345.png\" alt=\"avatar\" title=\"\">\n                </div>\n                <div class=\"image-caption\">avatar</div>\n            </figure><br>\n<p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class=\"line\">    table[bucketIndex] = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class=\"line\">    <span class=\"comment\">//键值对的数量size大于threshold时进行扩容操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size++ &gt;= threshold)</span><br><span class=\"line\">    <span class=\"comment\">//扩容使用resize()实现</span></span><br><span class=\"line\">        resize(<span class=\"number\">2</span> * table.length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此<br>这一步是很费时的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newCapacity)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] oldTable = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = oldTable.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">        threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Entry[] newTable = <span class=\"keyword\">new</span> Entry[newCapacity];</span><br><span class=\"line\">    transfer(newTable);</span><br><span class=\"line\">    table = newTable;</span><br><span class=\"line\">    threshold = (<span class=\"keyword\">int</span>)(newCapacity * loadFactor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Entry[] newTable)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] src = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = newTable.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; src.length; j++) &#123;</span><br><span class=\"line\">        Entry&lt;K,V&gt; e = src[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            src[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class=\"line\">                e.next = newTable[i];</span><br><span class=\"line\">                newTable[i] = e;</span><br><span class=\"line\">                e = next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>扩容-重新计算桶下标<br>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。<br>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：<br><br>capacity     : 00010000<br><br>new capacity : 00100000<br>对于一个 Key，</li>\n</ol>\n<p>它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；<br>如果为 1，那么得到的结果为原来的结果 +16。</p>\n<ol start=\"8\">\n<li>计算数组容量<br>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。<br></li>\n</ol>\n<p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mask |&#x3D; mask &gt;&gt; 1 11011000</span><br><span class=\"line\">mask |&#x3D; mask &gt;&gt; 2 11111110</span><br><span class=\"line\">mask |&#x3D; mask &gt;&gt; 4 11111111</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>链表转红黑树<br>从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HashMap源码解析\"><a href=\"#HashMap源码解析\" class=\"headerlink\" title=\"HashMap源码解析\"></a>HashMap源码解析</h2><ol>\n<li><p>默认的常量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建 HashMap 时未指定初始容量情况下的默认容量  16</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"comment\">//HashMap 的最大容量 2^30 </span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"comment\">//HashMap 默认的装载因子,当 HashMap 中元素数量超过容量装载因子时，进行　resize()　操作</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>; </span><br><span class=\"line\"><span class=\"comment\">//链表转红黑树的阈值 </span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>; </span><br><span class=\"line\"><span class=\"comment\">//用来确定何时将解决 hash 冲突的红黑树转变为链表</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure></li>\n<li><p>存储结构<br>内部包含了一个 Node 类型的数组 table。观察 Node 可以发现table是一个链表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The table, initialized on first use, and resized as</span></span><br><span class=\"line\"><span class=\"comment\"> * necessary. When allocated, length is always a power of two.</span></span><br><span class=\"line\"><span class=\"comment\"> * (We also tolerate length zero in some operations to allow</span></span><br><span class=\"line\"><span class=\"comment\"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>\n<p>Node 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 table 是一个链表。即数组中的每个位置被当<br>成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结<br>果相同的 Ndoe.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;<span class=\"comment\">//保存节点的hash值</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;<span class=\"comment\">//保存节点的key值</span></span><br><span class=\"line\">    V value;<span class=\"comment\">//保存节点的value值</span></span><br><span class=\"line\">    Node&lt;K,V&gt; next;<span class=\"comment\">//指向链表结构下的当前节点的 next 节点，红黑树 TreeNode 节点中也有用到</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash = hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span>        </span>&#123; <span class=\"keyword\">return</span> key; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span>      </span>&#123; <span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> key + <span class=\"string\">\"=\"</span> + value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">        V oldValue = value;</span><br><span class=\"line\">        value = newValue;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Map.Entry) &#123;</span><br><span class=\"line\">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">                Objects.equals(value, e.getValue()))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>TreeNode&lt;K,V&gt; 继承 LinkedHashMap.Entry&lt;K,V&gt;，用来实现红黑树相关的存储结构</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; parent;  <span class=\"comment\">// 存储当前节点的父节点</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; left;　<span class=\"comment\">//存储当前节点的左孩子</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; right;　<span class=\"comment\">//存储当前节点的右孩子</span></span><br><span class=\"line\">        TreeNode&lt;K,V&gt; prev;    <span class=\"comment\">// 存储当前节点的前一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> red;　<span class=\"comment\">// 存储当前节点的颜色（红、黑）</span></span><br><span class=\"line\">        TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode(<span class=\"keyword\">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(hash, key, val, next);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * Returns root of tree containing this node.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">root</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; r = <span class=\"keyword\">this</span>, p;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((p = r.parent) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                r = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HashMap的结构<br></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"1563864906121.png\" alt=\"avatar\" title=\"\">\n                </div>\n                <div class=\"image-caption\">avatar</div>\n            </figure><br>\n\n\n</li>\n</ol>\n<ol start=\"4\">\n<li>拉链法的工作原理<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashMap&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.put(<span class=\"string\">\"K1\"</span>, <span class=\"string\">\"V1\"</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">\"K2\"</span>, <span class=\"string\">\"V2\"</span>);</span><br><span class=\"line\">map.put(<span class=\"string\">\"K3\"</span>, <span class=\"string\">\"V3\"</span>);</span><br></pre></td></tr></table></figure>\n. 新建一个 HashMap，默认大小为 16；<br><br>. 插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。<br><br>. 插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。<br><br>. 插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在&lt;K2,V2&gt; 前面。<br><br>注意：应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头<br>部<br></li>\n</ol>\n<p>查找需要分成两步进行：<br>计算键值对所在的桶；<br>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</p>\n<ol start=\"5\">\n<li>put操作<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class=\"line\">        inflateTable(threshold);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 键为 null 单独处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> putForNullKey(value);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key);</span><br><span class=\"line\">    <span class=\"comment\">// 确定桶下标</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);</span><br><span class=\"line\">    <span class=\"comment\">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"comment\">// 插入新键值对</span></span><br><span class=\"line\">    addEntry(hash, key, value, i);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，<br>那么就可以将这个操作转换为位运算。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下<br>标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">putForNullKey</span><span class=\"params\">(V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[<span class=\"number\">0</span>]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.key == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            e.value = value;</span><br><span class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        addEntry(<span class=\"number\">0</span>, <span class=\"keyword\">null</span>, value, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size &gt;= threshold) &amp;&amp; (<span class=\"keyword\">null</span> != table[bucketIndex])) &#123;</span><br><span class=\"line\">        resize(<span class=\"number\">2</span> * table.length);</span><br><span class=\"line\">        hash = (<span class=\"keyword\">null</span> != key) ? hash(key) : <span class=\"number\">0</span>;</span><br><span class=\"line\">        bucketIndex = indexFor(hash, table.length);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">        createEntry(hash, key, value, bucketIndex);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class=\"line\">    <span class=\"comment\">// 头插法，链表头部指向新的键值对</span></span><br><span class=\"line\">    table[bucketIndex] = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>扩容-基本原理<br>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长<br>度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。<br>为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。<br>HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。<br>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</li>\n</ol>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"1563867424345345.png\" alt=\"avatar\" title=\"\">\n                </div>\n                <div class=\"image-caption\">avatar</div>\n            </figure><br>\n<p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class=\"line\">    table[bucketIndex] = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class=\"line\">    <span class=\"comment\">//键值对的数量size大于threshold时进行扩容操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size++ &gt;= threshold)</span><br><span class=\"line\">    <span class=\"comment\">//扩容使用resize()实现</span></span><br><span class=\"line\">        resize(<span class=\"number\">2</span> * table.length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此<br>这一步是很费时的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newCapacity)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] oldTable = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = oldTable.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">        threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Entry[] newTable = <span class=\"keyword\">new</span> Entry[newCapacity];</span><br><span class=\"line\">    transfer(newTable);</span><br><span class=\"line\">    table = newTable;</span><br><span class=\"line\">    threshold = (<span class=\"keyword\">int</span>)(newCapacity * loadFactor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Entry[] newTable)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] src = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = newTable.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; src.length; j++) &#123;</span><br><span class=\"line\">        Entry&lt;K,V&gt; e = src[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            src[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class=\"line\">                e.next = newTable[i];</span><br><span class=\"line\">                newTable[i] = e;</span><br><span class=\"line\">                e = next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"7\">\n<li>扩容-重新计算桶下标<br>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。<br>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：<br><br>capacity     : 00010000<br><br>new capacity : 00100000<br>对于一个 Key，</li>\n</ol>\n<p>它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；<br>如果为 1，那么得到的结果为原来的结果 +16。</p>\n<ol start=\"8\">\n<li>计算数组容量<br>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。<br></li>\n</ol>\n<p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mask |&#x3D; mask &gt;&gt; 1 11011000</span><br><span class=\"line\">mask |&#x3D; mask &gt;&gt; 2 11111110</span><br><span class=\"line\">mask |&#x3D; mask &gt;&gt; 4 11111111</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>链表转红黑树<br>从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。</li>\n</ol>\n"},{"title":"hexo的使用","date":"2018-11-07T07:55:28.000Z","_content":"### Hexo部署命令的使用\n1. 在source\\_posts文件夹下创建一个新的md文件\n```\nhexo new \"***\"\n```\n2. 在public文件夹下面生成静态文件\n```\nhexo generate 或者 hexo g\n```\n3. 启动本地服务，先观察部署的md文件是否生效\n```\nhexo server 或者 hexo s\n```\n4. 观察无误后，可以进行网站的部署\n```\nhexo deploy 或者 hexo d\n```\n---\n5. *public静态文件的清理命令*\n```\nhexo clean\n```\n---\n\n","source":"_posts/hexo的使用.md","raw":"---\ntitle: hexo的使用\ndate: 2018-11-07 15:55:28\ntags: \n      - Hexo\n      - Blog\ncategories: \"Hexo教程\"\n---\n### Hexo部署命令的使用\n1. 在source\\_posts文件夹下创建一个新的md文件\n```\nhexo new \"***\"\n```\n2. 在public文件夹下面生成静态文件\n```\nhexo generate 或者 hexo g\n```\n3. 启动本地服务，先观察部署的md文件是否生效\n```\nhexo server 或者 hexo s\n```\n4. 观察无误后，可以进行网站的部署\n```\nhexo deploy 或者 hexo d\n```\n---\n5. *public静态文件的清理命令*\n```\nhexo clean\n```\n---\n\n","slug":"hexo的使用","published":1,"updated":"2020-07-30T14:28:02.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd9ufp4b0002pwlga46l2lby","content":"<h3 id=\"Hexo部署命令的使用\"><a href=\"#Hexo部署命令的使用\" class=\"headerlink\" title=\"Hexo部署命令的使用\"></a>Hexo部署命令的使用</h3><ol>\n<li>在source_posts文件夹下创建一个新的md文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;***&quot;</span><br></pre></td></tr></table></figure></li>\n<li>在public文件夹下面生成静态文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate 或者 hexo g</span><br></pre></td></tr></table></figure></li>\n<li>启动本地服务，先观察部署的md文件是否生效<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server 或者 hexo s</span><br></pre></td></tr></table></figure></li>\n<li>观察无误后，可以进行网站的部署<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy 或者 hexo d</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<ol start=\"5\">\n<li><em>public静态文件的清理命令</em><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Hexo部署命令的使用\"><a href=\"#Hexo部署命令的使用\" class=\"headerlink\" title=\"Hexo部署命令的使用\"></a>Hexo部署命令的使用</h3><ol>\n<li>在source_posts文件夹下创建一个新的md文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new &quot;***&quot;</span><br></pre></td></tr></table></figure></li>\n<li>在public文件夹下面生成静态文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate 或者 hexo g</span><br></pre></td></tr></table></figure></li>\n<li>启动本地服务，先观察部署的md文件是否生效<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server 或者 hexo s</span><br></pre></td></tr></table></figure></li>\n<li>观察无误后，可以进行网站的部署<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy 或者 hexo d</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<ol start=\"5\">\n<li><em>public静态文件的清理命令</em><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n"},{"title":"java内存模型","date":"2019-07-10T03:14:24.000Z","_content":"### JAVA内存模型（Jave Memory Model:JMM）\n#### 一、CPU和内存的交互\n在计算机中，cpu和内存的交互最为频繁，但是随着cpu的发展，内存的读写速度也远远赶不上cpu。因此cpu厂商在每颗cpu上加上高速缓存，用于缓解这种CPU与内存间的速度不匹配问题情况。cpu和内存的交互大致如下。\n![avatar](2019071002.png)\n\n#### 二、多核CPU多级缓存一致性协议MESI\n多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致性,不让系统数据混乱。这里就引出了一个一致性的协议MESI。\nCPU中每个缓存行（caceh line)使用4种状态进行标记（使用额外的两位(bit)表示):<br>\n\nM: 被修改（Modified)<br>\n\n该缓存行只被缓存在该CPU的缓存中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。\n\n当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。<br>\n\nE: 独享的（Exclusive)<br>\n\n该缓存行只被缓存在该CPU的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。\n\n同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。<br>\n\nS: 共享的（Shared)<br>\n\n该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。<br>\n\nI: 无效的（Invalid）<br>\n\n该缓存是无效的（可能有其它CPU修改了该缓存行）。<br>\n\n#### 三、什么是JMM？\n\nJMM即为JAVA 内存模型（java memory model）。因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。<br>\nJava内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。JMM从java 5开始的JSR-133发布后，已经成熟和完善起来。<br>\nJMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。<br>\n从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory）<br>\n本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。<br>\n![avatar](2019071001.png)\n\n#### 四、java内存模型抽象结构图\n![avatar](2019071003.png)<br>\nJMM（java memory model）java内存模型主要目标是定义程序中的变量，（此处所指的变量是实例字段、静态字段等，不包含局部变量和函数参数，因为这两种是线程私有且无法共享）<br>\n在虚拟机中规定了存储到内存与从内存读取出来的5规则细节，Java 内存模型规定所有变量都存储在主内存中，每条线程还有自己的工作内存，工作内存保存了该线程使用到的变量（主内存副本拷贝），线程对变量的所有操作（读取、赋值）都必须在自己的工作内存中进行而不能直接读写主内存的变量，不同线程之间无法相互直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。<br>\n\n![avatar](2019071005.png)<br>\n\nJava 内存模型对主内存与工作内存之间的具体交互协议定义了八种操作，具体如下：\n\n1. lock（锁定）：作用于主内存变量，把一个变量标识为一条线程独占状态。\n\n2. unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。\n\n3. read（读取）：作用于主内存变量，把一个变量从主内存传输到线程的工作内存中，以便随后的 load 动作使用。\n\n4. load（载入）：作用于工作内存变量，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。\n\n5. use（使用）：作用于工作内存变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量值的字节码指令时执行此操作。\n\n6. assign（赋值）：作用于工作内存变量，把一个从执行引擎接收的值赋值给工作内存的变量，每当虚拟机遇到一个需要给变量进行赋值的字节码指令时执行此操作。\n\n7. store（存储）：作用于工作内存变量，把工作内存中一个变量的值传递到主内存中，以便后续 write 操作。\n\n8. write（写入）：作用于主内存变量，把 store 操作从工作内存中得到的值放入主内存变量中。\n<br>br\n![avatar](2019071004.png)<br>\n\n如果要把一个变量从主内存复制到工作内存就必须按顺序执行 read 和 load 操作，从工作内存同步回主内存就必须顺序执行 store 和 write 操作<br>\n但是 JVM 只要求了操作的顺序而没有要求上述操作必须保证连续性，所以实质执行中 read 和 load 间及 store 和 write 间是可以插入其他指令的。<br>\n\n\n其实 Java JMM 内存模型是围绕并发编程中原子性、可见性、有序性三个特征来建立的，关于原子性、可见性、有序性的理解如下：\n\n原子性：就是说一个操作不能被打断，要么执行完要么不执行，类似事务操作，Java 基本类型数据的访问大都是原子操作，long 和 double 类型是 64 位，在 32 位 JVM 中会将 64 位数据的读写操作分成两次 32 位来处理，所以 long 和 double 在 32 位 JVM 中是非原子操作，也就是说在并发访问时是线程非安全的，要想保证原子性就得对访问该数据的地方进行同步操作，譬如 <font color=\"red\">synchronized</font> 等。\n\n可见性：就是说当一个线程对共享变量做了修改后其他线程可以立即感知到该共享变量的改变，从 Java 内存模型我们就能看出来多线程访问共享变量都要经过线程工作内存到主存的复制和主存到线程工作内存的复制操作，所以普通共享变量就无法保证可见性了；<font color=\"red\">Java 提供了 volatile 修饰符来保证变量的可见性，每次使用 volatile 变量都会主动从主存中刷新，除此之外 synchronized、Lock、final 都可以保证变量的可见性。</font>\n\n有序性：就是说 Java 内存模型中的指令重排不会影响单线程的执行顺序，但是会影响多线程并发执行的正确性，所以在并发中我们必须要想办法保证并发代码的有序性；<font color=\"red\">在 Java 里可以通过 volatile 关键字保证一定的有序性，还可以通过 synchronized、Lock 来保证有序性</font>，因为 synchronized、Lock 保证了每一时刻只有一个线程执行同步代码相当于单线程执行，所以自然不会有有序性的问题；除此之外 Java 内存模型通过 happens-before 原则如果能推导出来两个操作的执行顺序就能先天保证有序性，否则无法保证，关于 happens-before 原则可以查阅相关资料。\n\n所以说如果想让 Java 并发程序正确的执行必须保证原子性、有序性、可见性，只要三者中有任意一个不满足并发都无法正确执行。","source":"_posts/java内存模型.md","raw":"---\ntitle: java内存模型\ndate: 2019-07-10 11:14:24\ntags: \n- java内存\ncategories: \"java技术\"    \n---\n### JAVA内存模型（Jave Memory Model:JMM）\n#### 一、CPU和内存的交互\n在计算机中，cpu和内存的交互最为频繁，但是随着cpu的发展，内存的读写速度也远远赶不上cpu。因此cpu厂商在每颗cpu上加上高速缓存，用于缓解这种CPU与内存间的速度不匹配问题情况。cpu和内存的交互大致如下。\n![avatar](2019071002.png)\n\n#### 二、多核CPU多级缓存一致性协议MESI\n多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致性,不让系统数据混乱。这里就引出了一个一致性的协议MESI。\nCPU中每个缓存行（caceh line)使用4种状态进行标记（使用额外的两位(bit)表示):<br>\n\nM: 被修改（Modified)<br>\n\n该缓存行只被缓存在该CPU的缓存中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。\n\n当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。<br>\n\nE: 独享的（Exclusive)<br>\n\n该缓存行只被缓存在该CPU的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。\n\n同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。<br>\n\nS: 共享的（Shared)<br>\n\n该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。<br>\n\nI: 无效的（Invalid）<br>\n\n该缓存是无效的（可能有其它CPU修改了该缓存行）。<br>\n\n#### 三、什么是JMM？\n\nJMM即为JAVA 内存模型（java memory model）。因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。<br>\nJava内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。JMM从java 5开始的JSR-133发布后，已经成熟和完善起来。<br>\nJMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。<br>\n从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory）<br>\n本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。<br>\n![avatar](2019071001.png)\n\n#### 四、java内存模型抽象结构图\n![avatar](2019071003.png)<br>\nJMM（java memory model）java内存模型主要目标是定义程序中的变量，（此处所指的变量是实例字段、静态字段等，不包含局部变量和函数参数，因为这两种是线程私有且无法共享）<br>\n在虚拟机中规定了存储到内存与从内存读取出来的5规则细节，Java 内存模型规定所有变量都存储在主内存中，每条线程还有自己的工作内存，工作内存保存了该线程使用到的变量（主内存副本拷贝），线程对变量的所有操作（读取、赋值）都必须在自己的工作内存中进行而不能直接读写主内存的变量，不同线程之间无法相互直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。<br>\n\n![avatar](2019071005.png)<br>\n\nJava 内存模型对主内存与工作内存之间的具体交互协议定义了八种操作，具体如下：\n\n1. lock（锁定）：作用于主内存变量，把一个变量标识为一条线程独占状态。\n\n2. unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。\n\n3. read（读取）：作用于主内存变量，把一个变量从主内存传输到线程的工作内存中，以便随后的 load 动作使用。\n\n4. load（载入）：作用于工作内存变量，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。\n\n5. use（使用）：作用于工作内存变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量值的字节码指令时执行此操作。\n\n6. assign（赋值）：作用于工作内存变量，把一个从执行引擎接收的值赋值给工作内存的变量，每当虚拟机遇到一个需要给变量进行赋值的字节码指令时执行此操作。\n\n7. store（存储）：作用于工作内存变量，把工作内存中一个变量的值传递到主内存中，以便后续 write 操作。\n\n8. write（写入）：作用于主内存变量，把 store 操作从工作内存中得到的值放入主内存变量中。\n<br>br\n![avatar](2019071004.png)<br>\n\n如果要把一个变量从主内存复制到工作内存就必须按顺序执行 read 和 load 操作，从工作内存同步回主内存就必须顺序执行 store 和 write 操作<br>\n但是 JVM 只要求了操作的顺序而没有要求上述操作必须保证连续性，所以实质执行中 read 和 load 间及 store 和 write 间是可以插入其他指令的。<br>\n\n\n其实 Java JMM 内存模型是围绕并发编程中原子性、可见性、有序性三个特征来建立的，关于原子性、可见性、有序性的理解如下：\n\n原子性：就是说一个操作不能被打断，要么执行完要么不执行，类似事务操作，Java 基本类型数据的访问大都是原子操作，long 和 double 类型是 64 位，在 32 位 JVM 中会将 64 位数据的读写操作分成两次 32 位来处理，所以 long 和 double 在 32 位 JVM 中是非原子操作，也就是说在并发访问时是线程非安全的，要想保证原子性就得对访问该数据的地方进行同步操作，譬如 <font color=\"red\">synchronized</font> 等。\n\n可见性：就是说当一个线程对共享变量做了修改后其他线程可以立即感知到该共享变量的改变，从 Java 内存模型我们就能看出来多线程访问共享变量都要经过线程工作内存到主存的复制和主存到线程工作内存的复制操作，所以普通共享变量就无法保证可见性了；<font color=\"red\">Java 提供了 volatile 修饰符来保证变量的可见性，每次使用 volatile 变量都会主动从主存中刷新，除此之外 synchronized、Lock、final 都可以保证变量的可见性。</font>\n\n有序性：就是说 Java 内存模型中的指令重排不会影响单线程的执行顺序，但是会影响多线程并发执行的正确性，所以在并发中我们必须要想办法保证并发代码的有序性；<font color=\"red\">在 Java 里可以通过 volatile 关键字保证一定的有序性，还可以通过 synchronized、Lock 来保证有序性</font>，因为 synchronized、Lock 保证了每一时刻只有一个线程执行同步代码相当于单线程执行，所以自然不会有有序性的问题；除此之外 Java 内存模型通过 happens-before 原则如果能推导出来两个操作的执行顺序就能先天保证有序性，否则无法保证，关于 happens-before 原则可以查阅相关资料。\n\n所以说如果想让 Java 并发程序正确的执行必须保证原子性、有序性、可见性，只要三者中有任意一个不满足并发都无法正确执行。","slug":"java内存模型","published":1,"updated":"2020-07-30T14:28:02.188Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckd9ufp4e0005pwlgazayhc7a","content":"<h3 id=\"JAVA内存模型（Jave-Memory-Model-JMM）\"><a href=\"#JAVA内存模型（Jave-Memory-Model-JMM）\" class=\"headerlink\" title=\"JAVA内存模型（Jave Memory Model:JMM）\"></a>JAVA内存模型（Jave Memory Model:JMM）</h3><h4 id=\"一、CPU和内存的交互\"><a href=\"#一、CPU和内存的交互\" class=\"headerlink\" title=\"一、CPU和内存的交互\"></a>一、CPU和内存的交互</h4><p>在计算机中，cpu和内存的交互最为频繁，但是随着cpu的发展，内存的读写速度也远远赶不上cpu。因此cpu厂商在每颗cpu上加上高速缓存，用于缓解这种CPU与内存间的速度不匹配问题情况。cpu和内存的交互大致如下。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"2019071002.png\" alt=\"avatar\" title=\"\">\n                </div>\n                <div class=\"image-caption\">avatar</div>\n            </figure>\n\n<h4 id=\"二、多核CPU多级缓存一致性协议MESI\"><a href=\"#二、多核CPU多级缓存一致性协议MESI\" class=\"headerlink\" title=\"二、多核CPU多级缓存一致性协议MESI\"></a>二、多核CPU多级缓存一致性协议MESI</h4><p>多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致性,不让系统数据混乱。这里就引出了一个一致性的协议MESI。<br>CPU中每个缓存行（caceh line)使用4种状态进行标记（使用额外的两位(bit)表示):<br></p>\n<p>M: 被修改（Modified)<br></p>\n<p>该缓存行只被缓存在该CPU的缓存中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。</p>\n<p>当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。<br></p>\n<p>E: 独享的（Exclusive)<br></p>\n<p>该缓存行只被缓存在该CPU的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。</p>\n<p>同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。<br></p>\n<p>S: 共享的（Shared)<br></p>\n<p>该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。<br></p>\n<p>I: 无效的（Invalid）<br></p>\n<p>该缓存是无效的（可能有其它CPU修改了该缓存行）。<br></p>\n<h4 id=\"三、什么是JMM？\"><a href=\"#三、什么是JMM？\" class=\"headerlink\" title=\"三、什么是JMM？\"></a>三、什么是JMM？</h4><p>JMM即为JAVA 内存模型（java memory model）。因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。<br><br>Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。JMM从java 5开始的JSR-133发布后，已经成熟和完善起来。<br><br>JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。<br><br>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory）<br><br>本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。<br></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"2019071001.png\" alt=\"avatar\" title=\"\">\n                </div>\n                <div class=\"image-caption\">avatar</div>\n            </figure>\n\n<h4 id=\"四、java内存模型抽象结构图\"><a href=\"#四、java内存模型抽象结构图\" class=\"headerlink\" title=\"四、java内存模型抽象结构图\"></a>四、java内存模型抽象结构图</h4><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"2019071003.png\" alt=\"avatar\" title=\"\">\n                </div>\n                <div class=\"image-caption\">avatar</div>\n            </figure><br>\n<p>JMM（java memory model）java内存模型主要目标是定义程序中的变量，（此处所指的变量是实例字段、静态字段等，不包含局部变量和函数参数，因为这两种是线程私有且无法共享）<br><br>在虚拟机中规定了存储到内存与从内存读取出来的5规则细节，Java 内存模型规定所有变量都存储在主内存中，每条线程还有自己的工作内存，工作内存保存了该线程使用到的变量（主内存副本拷贝），线程对变量的所有操作（读取、赋值）都必须在自己的工作内存中进行而不能直接读写主内存的变量，不同线程之间无法相互直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。<br></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"2019071005.png\" alt=\"avatar\" title=\"\">\n                </div>\n                <div class=\"image-caption\">avatar</div>\n            </figure><br>\n\n<p>Java 内存模型对主内存与工作内存之间的具体交互协议定义了八种操作，具体如下：</p>\n<ol>\n<li><p>lock（锁定）：作用于主内存变量，把一个变量标识为一条线程独占状态。</p>\n</li>\n<li><p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>\n</li>\n<li><p>read（读取）：作用于主内存变量，把一个变量从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</p>\n</li>\n<li><p>load（载入）：作用于工作内存变量，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</p>\n</li>\n<li><p>use（使用）：作用于工作内存变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量值的字节码指令时执行此操作。</p>\n</li>\n<li><p>assign（赋值）：作用于工作内存变量，把一个从执行引擎接收的值赋值给工作内存的变量，每当虚拟机遇到一个需要给变量进行赋值的字节码指令时执行此操作。</p>\n</li>\n<li><p>store（存储）：作用于工作内存变量，把工作内存中一个变量的值传递到主内存中，以便后续 write 操作。</p>\n</li>\n<li><p>write（写入）：作用于主内存变量，把 store 操作从工作内存中得到的值放入主内存变量中。<br><br>br</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"2019071004.png\" alt=\"avatar\" title=\"\">\n                </div>\n                <div class=\"image-caption\">avatar</div>\n            </figure><br>\n\n</li>\n</ol>\n<p>如果要把一个变量从主内存复制到工作内存就必须按顺序执行 read 和 load 操作，从工作内存同步回主内存就必须顺序执行 store 和 write 操作<br><br>但是 JVM 只要求了操作的顺序而没有要求上述操作必须保证连续性，所以实质执行中 read 和 load 间及 store 和 write 间是可以插入其他指令的。<br></p>\n<p>其实 Java JMM 内存模型是围绕并发编程中原子性、可见性、有序性三个特征来建立的，关于原子性、可见性、有序性的理解如下：</p>\n<p>原子性：就是说一个操作不能被打断，要么执行完要么不执行，类似事务操作，Java 基本类型数据的访问大都是原子操作，long 和 double 类型是 64 位，在 32 位 JVM 中会将 64 位数据的读写操作分成两次 32 位来处理，所以 long 和 double 在 32 位 JVM 中是非原子操作，也就是说在并发访问时是线程非安全的，要想保证原子性就得对访问该数据的地方进行同步操作，譬如 <font color=\"red\">synchronized</font> 等。</p>\n<p>可见性：就是说当一个线程对共享变量做了修改后其他线程可以立即感知到该共享变量的改变，从 Java 内存模型我们就能看出来多线程访问共享变量都要经过线程工作内存到主存的复制和主存到线程工作内存的复制操作，所以普通共享变量就无法保证可见性了；<font color=\"red\">Java 提供了 volatile 修饰符来保证变量的可见性，每次使用 volatile 变量都会主动从主存中刷新，除此之外 synchronized、Lock、final 都可以保证变量的可见性。</font></p>\n<p>有序性：就是说 Java 内存模型中的指令重排不会影响单线程的执行顺序，但是会影响多线程并发执行的正确性，所以在并发中我们必须要想办法保证并发代码的有序性；<font color=\"red\">在 Java 里可以通过 volatile 关键字保证一定的有序性，还可以通过 synchronized、Lock 来保证有序性</font>，因为 synchronized、Lock 保证了每一时刻只有一个线程执行同步代码相当于单线程执行，所以自然不会有有序性的问题；除此之外 Java 内存模型通过 happens-before 原则如果能推导出来两个操作的执行顺序就能先天保证有序性，否则无法保证，关于 happens-before 原则可以查阅相关资料。</p>\n<p>所以说如果想让 Java 并发程序正确的执行必须保证原子性、有序性、可见性，只要三者中有任意一个不满足并发都无法正确执行。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"JAVA内存模型（Jave-Memory-Model-JMM）\"><a href=\"#JAVA内存模型（Jave-Memory-Model-JMM）\" class=\"headerlink\" title=\"JAVA内存模型（Jave Memory Model:JMM）\"></a>JAVA内存模型（Jave Memory Model:JMM）</h3><h4 id=\"一、CPU和内存的交互\"><a href=\"#一、CPU和内存的交互\" class=\"headerlink\" title=\"一、CPU和内存的交互\"></a>一、CPU和内存的交互</h4><p>在计算机中，cpu和内存的交互最为频繁，但是随着cpu的发展，内存的读写速度也远远赶不上cpu。因此cpu厂商在每颗cpu上加上高速缓存，用于缓解这种CPU与内存间的速度不匹配问题情况。cpu和内存的交互大致如下。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"2019071002.png\" alt=\"avatar\" title=\"\">\n                </div>\n                <div class=\"image-caption\">avatar</div>\n            </figure>\n\n<h4 id=\"二、多核CPU多级缓存一致性协议MESI\"><a href=\"#二、多核CPU多级缓存一致性协议MESI\" class=\"headerlink\" title=\"二、多核CPU多级缓存一致性协议MESI\"></a>二、多核CPU多级缓存一致性协议MESI</h4><p>多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致性,不让系统数据混乱。这里就引出了一个一致性的协议MESI。<br>CPU中每个缓存行（caceh line)使用4种状态进行标记（使用额外的两位(bit)表示):<br></p>\n<p>M: 被修改（Modified)<br></p>\n<p>该缓存行只被缓存在该CPU的缓存中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。</p>\n<p>当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。<br></p>\n<p>E: 独享的（Exclusive)<br></p>\n<p>该缓存行只被缓存在该CPU的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。</p>\n<p>同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。<br></p>\n<p>S: 共享的（Shared)<br></p>\n<p>该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。<br></p>\n<p>I: 无效的（Invalid）<br></p>\n<p>该缓存是无效的（可能有其它CPU修改了该缓存行）。<br></p>\n<h4 id=\"三、什么是JMM？\"><a href=\"#三、什么是JMM？\" class=\"headerlink\" title=\"三、什么是JMM？\"></a>三、什么是JMM？</h4><p>JMM即为JAVA 内存模型（java memory model）。因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。<br><br>Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。JMM从java 5开始的JSR-133发布后，已经成熟和完善起来。<br><br>JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。<br><br>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory）<br><br>本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。<br></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"2019071001.png\" alt=\"avatar\" title=\"\">\n                </div>\n                <div class=\"image-caption\">avatar</div>\n            </figure>\n\n<h4 id=\"四、java内存模型抽象结构图\"><a href=\"#四、java内存模型抽象结构图\" class=\"headerlink\" title=\"四、java内存模型抽象结构图\"></a>四、java内存模型抽象结构图</h4><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"2019071003.png\" alt=\"avatar\" title=\"\">\n                </div>\n                <div class=\"image-caption\">avatar</div>\n            </figure><br>\n<p>JMM（java memory model）java内存模型主要目标是定义程序中的变量，（此处所指的变量是实例字段、静态字段等，不包含局部变量和函数参数，因为这两种是线程私有且无法共享）<br><br>在虚拟机中规定了存储到内存与从内存读取出来的5规则细节，Java 内存模型规定所有变量都存储在主内存中，每条线程还有自己的工作内存，工作内存保存了该线程使用到的变量（主内存副本拷贝），线程对变量的所有操作（读取、赋值）都必须在自己的工作内存中进行而不能直接读写主内存的变量，不同线程之间无法相互直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。<br></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"2019071005.png\" alt=\"avatar\" title=\"\">\n                </div>\n                <div class=\"image-caption\">avatar</div>\n            </figure><br>\n\n<p>Java 内存模型对主内存与工作内存之间的具体交互协议定义了八种操作，具体如下：</p>\n<ol>\n<li><p>lock（锁定）：作用于主内存变量，把一个变量标识为一条线程独占状态。</p>\n</li>\n<li><p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p>\n</li>\n<li><p>read（读取）：作用于主内存变量，把一个变量从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</p>\n</li>\n<li><p>load（载入）：作用于工作内存变量，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</p>\n</li>\n<li><p>use（使用）：作用于工作内存变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量值的字节码指令时执行此操作。</p>\n</li>\n<li><p>assign（赋值）：作用于工作内存变量，把一个从执行引擎接收的值赋值给工作内存的变量，每当虚拟机遇到一个需要给变量进行赋值的字节码指令时执行此操作。</p>\n</li>\n<li><p>store（存储）：作用于工作内存变量，把工作内存中一个变量的值传递到主内存中，以便后续 write 操作。</p>\n</li>\n<li><p>write（写入）：作用于主内存变量，把 store 操作从工作内存中得到的值放入主内存变量中。<br><br>br</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"2019071004.png\" alt=\"avatar\" title=\"\">\n                </div>\n                <div class=\"image-caption\">avatar</div>\n            </figure><br>\n\n</li>\n</ol>\n<p>如果要把一个变量从主内存复制到工作内存就必须按顺序执行 read 和 load 操作，从工作内存同步回主内存就必须顺序执行 store 和 write 操作<br><br>但是 JVM 只要求了操作的顺序而没有要求上述操作必须保证连续性，所以实质执行中 read 和 load 间及 store 和 write 间是可以插入其他指令的。<br></p>\n<p>其实 Java JMM 内存模型是围绕并发编程中原子性、可见性、有序性三个特征来建立的，关于原子性、可见性、有序性的理解如下：</p>\n<p>原子性：就是说一个操作不能被打断，要么执行完要么不执行，类似事务操作，Java 基本类型数据的访问大都是原子操作，long 和 double 类型是 64 位，在 32 位 JVM 中会将 64 位数据的读写操作分成两次 32 位来处理，所以 long 和 double 在 32 位 JVM 中是非原子操作，也就是说在并发访问时是线程非安全的，要想保证原子性就得对访问该数据的地方进行同步操作，譬如 <font color=\"red\">synchronized</font> 等。</p>\n<p>可见性：就是说当一个线程对共享变量做了修改后其他线程可以立即感知到该共享变量的改变，从 Java 内存模型我们就能看出来多线程访问共享变量都要经过线程工作内存到主存的复制和主存到线程工作内存的复制操作，所以普通共享变量就无法保证可见性了；<font color=\"red\">Java 提供了 volatile 修饰符来保证变量的可见性，每次使用 volatile 变量都会主动从主存中刷新，除此之外 synchronized、Lock、final 都可以保证变量的可见性。</font></p>\n<p>有序性：就是说 Java 内存模型中的指令重排不会影响单线程的执行顺序，但是会影响多线程并发执行的正确性，所以在并发中我们必须要想办法保证并发代码的有序性；<font color=\"red\">在 Java 里可以通过 volatile 关键字保证一定的有序性，还可以通过 synchronized、Lock 来保证有序性</font>，因为 synchronized、Lock 保证了每一时刻只有一个线程执行同步代码相当于单线程执行，所以自然不会有有序性的问题；除此之外 Java 内存模型通过 happens-before 原则如果能推导出来两个操作的执行顺序就能先天保证有序性，否则无法保证，关于 happens-before 原则可以查阅相关资料。</p>\n<p>所以说如果想让 Java 并发程序正确的执行必须保证原子性、有序性、可见性，只要三者中有任意一个不满足并发都无法正确执行。</p>\n"}],"PostAsset":[{"_id":"source/_posts/java内存模型/2019071002.png","slug":"2019071002.png","post":"ckd9ufp4e0005pwlgazayhc7a","modified":0,"renderable":0},{"_id":"source/_posts/java内存模型/2019071005.png","slug":"2019071005.png","post":"ckd9ufp4e0005pwlgazayhc7a","modified":0,"renderable":0},{"_id":"source/_posts/HashMap/1563766617123.png","slug":"1563766617123.png","post":"ckd9ufp460000pwlg54gg5ann","modified":0,"renderable":0},{"_id":"source/_posts/HashMap/1563864906121.png","slug":"1563864906121.png","post":"ckd9ufp460000pwlg54gg5ann","modified":0,"renderable":0},{"_id":"source/_posts/HashMap/1563867424345345.png","slug":"1563867424345345.png","post":"ckd9ufp460000pwlg54gg5ann","modified":0,"renderable":0},{"_id":"source/_posts/java内存模型/2019071001.png","slug":"2019071001.png","post":"ckd9ufp4e0005pwlgazayhc7a","modified":0,"renderable":0},{"_id":"source/_posts/java内存模型/2019071003.png","slug":"2019071003.png","post":"ckd9ufp4e0005pwlgazayhc7a","modified":0,"renderable":0},{"_id":"source/_posts/java内存模型/2019071004.png","slug":"2019071004.png","post":"ckd9ufp4e0005pwlgazayhc7a","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckd9ufp460000pwlg54gg5ann","category_id":"ckd9ufp4c0003pwlg72qlfr8o","_id":"ckd9ufp4h0009pwlg7ea95g2n"},{"post_id":"ckd9ufp4b0002pwlga46l2lby","category_id":"ckd9ufp4g0006pwlgh9nv73l1","_id":"ckd9ufp4i000cpwlg1lai9gyq"},{"post_id":"ckd9ufp4e0005pwlgazayhc7a","category_id":"ckd9ufp4h000apwlggtyk3uff","_id":"ckd9ufp4j000gpwlg5va06u2w"}],"PostTag":[{"post_id":"ckd9ufp460000pwlg54gg5ann","tag_id":"ckd9ufp4d0004pwlg4om6falx","_id":"ckd9ufp4h0008pwlg9l9p3xtn"},{"post_id":"ckd9ufp4b0002pwlga46l2lby","tag_id":"ckd9ufp4g0007pwlg65n95ck3","_id":"ckd9ufp4j000epwlgcui37iki"},{"post_id":"ckd9ufp4b0002pwlga46l2lby","tag_id":"ckd9ufp4i000bpwlghacja53m","_id":"ckd9ufp4j000fpwlgaetvg9ba"},{"post_id":"ckd9ufp4e0005pwlgazayhc7a","tag_id":"ckd9ufp4j000dpwlg52gzc70h","_id":"ckd9ufp4k000hpwlgbuqq9g7p"}],"Tag":[{"name":"源码阅读","_id":"ckd9ufp4d0004pwlg4om6falx"},{"name":"Hexo","_id":"ckd9ufp4g0007pwlg65n95ck3"},{"name":"Blog","_id":"ckd9ufp4i000bpwlghacja53m"},{"name":"java内存","_id":"ckd9ufp4j000dpwlg52gzc70h"}]}}